CCS PCM C Compiler, Version 4.065, 13791               10-nov-08 20:42

               Filename: main16f688.lst

               ROM used: 605 words (15%)
                         Largest free fragment is 2048
               RAM used: 22 (9%) at main() level
                         33 (13%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   1E1
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  BTFSS  0B.5
001D:  GOTO   020
001E:  BTFSC  0B.2
001F:  GOTO   033
0020:  MOVF   27,W
0021:  MOVWF  04
0022:  MOVF   28,W
0023:  MOVWF  20
0024:  MOVF   29,W
0025:  MOVWF  21
0026:  MOVF   2A,W
0027:  MOVWF  22
0028:  MOVF   2B,W
0029:  MOVWF  23
002A:  MOVF   2C,W
002B:  MOVWF  24
002C:  MOVF   2D,W
002D:  MOVWF  0A
002E:  SWAPF  26,W
002F:  MOVWF  03
0030:  SWAPF  7F,F
0031:  SWAPF  7F,W
0032:  RETFIE
0033:  BCF    0A.3
0034:  GOTO   035
.................... #include <16F688.h> 
.................... //////// Standard Header file for the PIC16F688 device //////////////// 
.................... #device PIC16F688 
.................... #list 
....................  
.................... #device *=16 
.................... #device adc=8 
.................... #FUSES NOWDT, INTRC_IO, NOPROTECT, BROWNOUT, NOMCLR, NOCPD, PUT, IESO, FCMEN 
.................... #use delay(clock=8000000) 
*
0040:  MOVLW  08
0041:  SUBWF  3C,F
0042:  BTFSS  03.0
0043:  GOTO   050
0044:  MOVLW  3C
0045:  MOVWF  04
0046:  BCF    03.7
0047:  BCF    03.0
0048:  RRF    00,F
0049:  MOVF   00,W
004A:  BTFSC  03.2
004B:  GOTO   050
004C:  GOTO   04E
004D:  NOP
004E:  DECFSZ 00,F
004F:  GOTO   04D
0050:  RETLW  00
*
010C:  MOVLW  39
010D:  MOVWF  04
010E:  BCF    03.7
010F:  MOVF   00,W
0110:  BTFSC  03.2
0111:  GOTO   11F
0112:  MOVLW  02
0113:  MOVWF  21
0114:  CLRF   20
0115:  DECFSZ 20,F
0116:  GOTO   115
0117:  DECFSZ 21,F
0118:  GOTO   114
0119:  MOVLW  97
011A:  MOVWF  20
011B:  DECFSZ 20,F
011C:  GOTO   11B
011D:  DECFSZ 00,F
011E:  GOTO   112
011F:  RETLW  00
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #include "ds18b20.c" 
....................  
....................  
....................  
....................  
.................... //*************************************************************** 
....................  
.................... //RUTINAS DEL SENSOR DE TEMPERATURA DS18B20 
....................  
....................  
.................... #define DQ18B20 PIN_A4 
....................  
.................... //************************************************************** 
....................  
.................... short int  initErrDS18B20() 
.................... { 
....................   output_low(DQ18B20);          //Inicia bus,comprobando 
....................   delay_us(500);                //respuesta del DS18B20 
....................   output_float(DQ18B20); 
....................   delay_us(5); 
....................  
....................   if(!input(DQ18B20))           //si responde rapido mal  
....................     return (FALSE); 
....................  
....................   delay_us(80); 
....................  
....................   if(input(DQ18B20))            //despues de 80us,debe responder a 0 
....................     return (FALSE); 
....................  
....................   delay_us(420); 
....................   output_float(DQ18B20); 
....................  
....................   return(TRUE); 
.................... }   
....................        
.................... //************************************************************** 
....................  
.................... void initDS18B20() 
.................... { 
....................    
....................   output_low(DQ18B20);   //secuencia segun DATASHEET 
*
0051:  BSF    03.5
0052:  BCF    05.4
0053:  BCF    03.5
0054:  BCF    05.4
....................   delay_us(500); 
0055:  MOVLW  02
0056:  MOVWF  35
0057:  MOVLW  F8
0058:  MOVWF  3C
0059:  CALL   040
005A:  DECFSZ 35,F
005B:  GOTO   057
....................   output_float(DQ18B20); 
005C:  BSF    03.5
005D:  BSF    05.4
....................   delay_us(80); 
005E:  MOVLW  35
005F:  BCF    03.5
0060:  MOVWF  20
0061:  DECFSZ 20,F
0062:  GOTO   061
....................   delay_us(420); 
0063:  MOVLW  02
0064:  MOVWF  35
0065:  MOVLW  D0
0066:  MOVWF  3C
0067:  CALL   040
0068:  DECFSZ 35,F
0069:  GOTO   065
....................   output_float(DQ18B20); 
006A:  BSF    03.5
006B:  BSF    05.4
.................... } 
006C:  BCF    03.5
006D:  RETLW  00
....................  
.................... //************************************************************** 
.................... void enviaDS18B20(byte dato) 
.................... { 
....................  int cnt; 
....................   
....................  for(cnt=0;cnt<8;++cnt) 
006E:  CLRF   36
006F:  MOVF   36,W
0070:  SUBLW  07
0071:  BTFSS  03.0
0072:  GOTO   08F
....................  { 
....................   output_low(DQ18B20); 
0073:  BSF    03.5
0074:  BCF    05.4
0075:  BCF    03.5
0076:  BCF    05.4
....................   delay_us(2); 
0077:  GOTO   078
0078:  GOTO   079
....................   output_bit(DQ18B20,shift_right(&dato,1,0)); 
0079:  BCF    03.0
007A:  RRF    35,F
007B:  BTFSC  03.0
007C:  GOTO   07F
007D:  BCF    05.4
007E:  GOTO   080
007F:  BSF    05.4
0080:  BSF    03.5
0081:  BCF    05.4
....................   delay_us(60); 
0082:  MOVLW  27
0083:  BCF    03.5
0084:  MOVWF  20
0085:  DECFSZ 20,F
0086:  GOTO   085
0087:  GOTO   088
....................   output_float(DQ18B20); 
0088:  BSF    03.5
0089:  BSF    05.4
....................   delay_us(2); 
008A:  GOTO   08B
008B:  GOTO   08C
....................  } 
008C:  BCF    03.5
008D:  INCF   36,F
008E:  GOTO   06F
.................... } 
008F:  RETLW  00
....................  
.................... //**************************************************************** 
....................  
.................... byte leeDS18B20() 
.................... { 
....................   int cnt,dato; 
....................  
....................   for(cnt=0;cnt<8;++cnt) 
0090:  CLRF   35
0091:  MOVF   35,W
0092:  SUBLW  07
0093:  BTFSS  03.0
0094:  GOTO   0B2
....................   { 
....................    output_low(DQ18B20); 
0095:  BSF    03.5
0096:  BCF    05.4
0097:  BCF    03.5
0098:  BCF    05.4
....................    delay_us(2); 
0099:  GOTO   09A
009A:  GOTO   09B
....................    output_float(DQ18B20); 
009B:  BSF    03.5
009C:  BSF    05.4
....................    delay_us(8); 
009D:  MOVLW  05
009E:  BCF    03.5
009F:  MOVWF  20
00A0:  DECFSZ 20,F
00A1:  GOTO   0A0
....................    shift_right(&dato,1,input(DQ18B20)); 
00A2:  BSF    03.5
00A3:  BSF    05.4
00A4:  BCF    03.5
00A5:  BTFSC  05.4
00A6:  GOTO   0A9
00A7:  BCF    03.0
00A8:  GOTO   0AA
00A9:  BSF    03.0
00AA:  RRF    36,F
....................    delay_us(60); 
00AB:  MOVLW  27
00AC:  MOVWF  20
00AD:  DECFSZ 20,F
00AE:  GOTO   0AD
00AF:  GOTO   0B0
....................   } 
00B0:  INCF   35,F
00B1:  GOTO   091
....................  return (dato); 
00B2:  MOVF   36,W
00B3:  MOVWF  21
.................... } 
00B4:  RETLW  00
....................  
.................... //****************************************************************   
.................... byte leeRAMDS18B20(int pos) 
.................... { 
....................   byte dato[9];  
....................  
....................   if(pos > 8) 
....................     return 0; 
....................  
....................   initDS18B20(); 
....................   enviaDS18B20(0xCC);  //skip ROM 
....................   enviaDS18B20(0xBE);  //lee RAM 
....................    
....................   dato[0]=leeDS18B20(); //Temp. LSB 
....................   dato[1]=leeDS18B20(); //Temp. MSB  
....................   dato[2]=leeDS18B20(); // TH limit 
....................   dato[3]=leeDS18B20(); // TL limit 
....................   dato[4]=leeDS18B20(); // CONFIG 
....................   dato[5]=leeDS18B20(); // RES 0  
....................   dato[6]=leeDS18B20(); // RES 1  
....................   dato[7]=leeDS18B20(); // RES 2 
....................   dato[8]=leeDS18B20(); // CRC 
....................  
....................   return dato[pos]; 
....................  
.................... } 
.................... //****************************************************************** 
.................... int ponresDS18B20(int res) 
.................... { 
....................   int cfg; 
....................    
....................   if((res < 9) || (res >12)) 
....................       res=9; 
....................   cfg=((res-9)<<5); 
....................   if(!initErrDS18B20()) 
....................       return 99; 
....................   enviaDS18B20(0xCC); 
....................   enviaDS18B20(0x4E); 
....................   enviaDS18B20(0b01111101); 
....................   enviaDS18B20(0b11001001); 
....................   enviaDS18B20(cfg); 
....................  
....................   initDS18B20(); 
....................   enviaDS18B20(0xCC); 
....................   enviaDS18B20(0x48); 
....................   delay_ms(15); 
....................   return (leeRAMDS18B20((4  & 0b01100000)>>5)); 
.................... } 
....................    
.................... //******************************************************************** 
.................... float leeTempDS18B20() 
.................... { 
....................    
....................   int8 valor=0; 
00B5:  CLRF   34
....................    
....................   
....................   initDS18B20(); 
00B6:  CALL   051
....................   enviaDS18B20(0xCC);  //skip ROM 
00B7:  MOVLW  CC
00B8:  MOVWF  35
00B9:  CALL   06E
....................   enviaDS18B20(0x44);  //prepara conversion 
00BA:  MOVLW  44
00BB:  MOVWF  35
00BC:  CALL   06E
....................   output_high(DQ18B20); 
00BD:  BSF    03.5
00BE:  BCF    05.4
00BF:  BCF    03.5
00C0:  BSF    05.4
....................   leeDS18B20(); 
00C1:  CALL   090
....................   initDS18B20(); 
00C2:  CALL   051
....................   enviaDS18B20(0xCC);  //skip ROM 
00C3:  MOVLW  CC
00C4:  MOVWF  35
00C5:  CALL   06E
....................   enviaDS18B20(0xBE);  //prepara conversion 
00C6:  MOVLW  BE
00C7:  MOVWF  35
00C8:  CALL   06E
....................    
....................   valor=leeDS18B20(); 
00C9:  CALL   090
00CA:  MOVF   21,W
00CB:  MOVWF  34
....................    
....................   return (valor/2); 
00CC:  BCF    03.0
00CD:  RRF    34,W
00CE:  CLRF   36
00CF:  MOVWF  35
.................... }   
*
00EC:  RETLW  00
....................   
....................  
....................  
.................... #bit  LE1=0x07.4  // display LSB 
.................... #bit  LE2=0x07.5 
....................  
.................... #bit  GRADO=0x05.5 
.................... #byte PORTC=0x07 
....................  
....................  
....................  
.................... typedef int1 bool;  
....................  
....................  
.................... bool bInt5seg=FALSE;  //tiempo de 5seg. para sample temperatura 
*
01F1:  BCF    2E.0
.................... bool bInt100m=FALSE; 
01F2:  BCF    2E.1
.................... bool bUpDw=FALSE; 
01F3:  BCF    2E.2
....................  
....................  
.................... //**************Interrupciones****************************************************** 
.................... #INT_RTCC 
.................... void intTareas() 
.................... { 
....................    
....................    static int iTemp=0;   //cuenta para vis. temperatura 
01F4:  CLRF   2F
....................    static int iTemp2=0; 
01F5:  CLRF   30
....................  
....................   if(++iTemp>2)          //cuenta cada 100 ms,cambia estado cada seg. 
*
0035:  INCF   2F,F
0036:  MOVF   2F,W
0037:  SUBLW  02
0038:  BTFSC  03.0
0039:  GOTO   03C
....................   { 
....................    bInt100m=TRUE; 
003A:  BSF    2E.1
....................    iTemp=0; 
003B:  CLRF   2F
....................   } 
....................  
....................   if(++iTemp2>312)   //10 seg. 
003C:  INCF   30,F
....................   { 
....................     bInt5seg=TRUE; 
....................     iTemp2=0; 
....................   } 
....................  
....................  
.................... } 
.................... //******************************************************************************** 
003D:  BCF    0B.2
003E:  BCF    0A.3
003F:  GOTO   020
.................... void PWM(int8 iDuty) 
.................... { 
....................   unsigned long lDuty=0L; 
*
0161:  CLRF   35
0162:  CLRF   36
....................   int16 lY; 
....................    
....................       lDuty=(iDuty*1000)/100;     
0163:  CLRF   3A
0164:  MOVF   34,W
0165:  MOVWF  39
0166:  MOVLW  03
0167:  MOVWF  3C
0168:  MOVLW  E8
0169:  MOVWF  3B
*
017E:  MOVF   22,W
017F:  MOVWF  3A
0180:  MOVF   21,W
0181:  MOVWF  39
0182:  MOVF   3A,W
0183:  MOVWF  3C
0184:  MOVF   39,W
0185:  MOVWF  3B
0186:  CLRF   3E
0187:  MOVLW  64
0188:  MOVWF  3D
*
01AD:  MOVF   22,W
01AE:  MOVWF  36
01AF:  MOVF   21,W
01B0:  MOVWF  35
....................        
....................       output_low(PIN_A5); 
01B1:  BSF    03.5
01B2:  BCF    05.5
01B3:  BCF    03.5
01B4:  BCF    05.5
....................       delay_us(lDuty); 
01B5:  MOVF   36,W
01B6:  MOVWF  39
01B7:  INCF   39,F
01B8:  DECF   39,F
01B9:  BTFSC  03.2
01BA:  GOTO   1BF
01BB:  MOVLW  FF
01BC:  MOVWF  3C
01BD:  CALL   040
01BE:  GOTO   1B8
01BF:  MOVF   35,W
01C0:  MOVWF  3C
01C1:  CALL   040
....................       output_high(PIN_A5); 
01C2:  BSF    03.5
01C3:  BCF    05.5
01C4:  BCF    03.5
01C5:  BSF    05.5
....................       delay_us(1000-lDuty); 
01C6:  MOVF   35,W
01C7:  SUBLW  E8
01C8:  MOVWF  39
01C9:  MOVLW  03
01CA:  MOVWF  3A
01CB:  MOVF   36,W
01CC:  BTFSS  03.0
01CD:  INCFSZ 36,W
01CE:  SUBWF  3A,F
01CF:  MOVF   3A,W
01D0:  MOVWF  3B
01D1:  INCF   3B,F
01D2:  DECF   3B,F
01D3:  BTFSC  03.2
01D4:  GOTO   1D9
01D5:  MOVLW  FF
01D6:  MOVWF  3C
01D7:  CALL   040
01D8:  GOTO   1D2
01D9:  MOVF   39,W
01DA:  MOVWF  3C
01DB:  CALL   040
....................       delay_ms(1); 
01DC:  MOVLW  01
01DD:  MOVWF  39
01DE:  CALL   10C
.................... } 
01DF:  BCF    0A.3
01E0:  GOTO   25B (RETURN)
....................  
.................... //********************************************************************** 
.................... int8 bin2bcd(int8 bin) 
.................... { 
....................   int8 bcd; 
....................     
....................    bcd=(bin/10)<<4; 
*
0135:  MOVF   36,W
0136:  MOVWF  38
0137:  MOVLW  0A
0138:  MOVWF  39
0139:  CALL   120
013A:  SWAPF  21,W
013B:  MOVWF  37
013C:  MOVLW  F0
013D:  ANDWF  37,F
....................    bcd+=(bin%10); 
013E:  MOVF   36,W
013F:  MOVWF  38
0140:  MOVLW  0A
0141:  MOVWF  39
0142:  CALL   120
0143:  MOVF   20,W
0144:  ADDWF  37,F
....................     
....................    return (bcd); 
0145:  MOVF   37,W
0146:  MOVWF  21
.................... } 
0147:  RETLW  00
....................  
.................... //********************************************************************** 
.................... void visuHP7300(int8 Num) 
.................... { 
....................   int iPrimerDig; 
....................    
....................          
....................     PORTC=((bin2bcd(Num) & 0xF0) >> 4) | 0xF0 ; 
0148:  MOVF   34,W
0149:  MOVWF  36
014A:  CALL   135
014B:  MOVF   21,W
014C:  ANDLW  F0
014D:  MOVWF  20
014E:  SWAPF  20,F
014F:  MOVLW  0F
0150:  ANDWF  20,F
0151:  MOVF   20,W
0152:  IORLW  F0
0153:  MOVWF  07
....................     LE1=0;LE1=1; 
0154:  BCF    07.4
0155:  BSF    07.4
....................     PORTC=(bin2bcd(Num) & 0x0F) | 0xF0; 
0156:  MOVF   34,W
0157:  MOVWF  36
0158:  CALL   135
0159:  MOVF   21,W
015A:  ANDLW  0F
015B:  IORLW  F0
015C:  MOVWF  07
....................     LE2=0;LE2=1; 
015D:  BCF    07.5
015E:  BSF    07.5
....................      
.................... }    
015F:  BCF    0A.3
0160:  GOTO   236 (RETURN)
....................  
.................... //***************************************************************************** 
.................... void beep(int16 tone,int16 playtime) 
.................... { 
....................   int j,k;  
....................   int16 i; 
....................   int cycle;  
....................   j=tone/255; 
....................   cycle=tone-j*255; 
....................   for(i=0;i<playtime;i++) 
....................   { 
....................     output_low(PIN_A2); 
....................     for(k=0;k<j;k++) 
....................        delay_us(255); 
....................     delay_us(cycle); 
....................     output_high(PIN_A2); 
....................     for(k=0;k<j;k++) 
....................        delay_us(255); 
....................     delay_us(cycle); 
....................   } 
.................... } 
....................  
.................... //************************************************************************** 
.................... void main() 
.................... { 
*
01E1:  CLRF   04
01E2:  BCF    03.7
01E3:  MOVLW  1F
01E4:  ANDWF  03,F
01E5:  MOVLW  71
01E6:  BSF    03.5
01E7:  MOVWF  0F
01E8:  MOVF   0F,W
01E9:  BCF    03.5
01EA:  BCF    1F.6
01EB:  MOVLW  00
01EC:  BSF    03.5
01ED:  MOVWF  11
01EE:  MOVLW  07
01EF:  BCF    03.5
01F0:  MOVWF  19
....................   int8 iNivel; 
....................   int8 iTemperatura; 
....................   int8 i=100; 
*
01F6:  MOVLW  64
01F7:  MOVWF  33
....................    setup_adc_ports(NO_ANALOGS|VSS_VDD); 
01F8:  BCF    1F.6
01F9:  MOVLW  00
01FA:  BSF    03.5
01FB:  MOVWF  11
....................    setup_adc(ADC_OFF); 
01FC:  BCF    03.5
01FD:  BCF    1F.0
....................     
....................    setup_timer_1(T1_DISABLED); 
01FE:  CLRF   10
....................    setup_comparator(NC_NC); 
01FF:  MOVLW  07
0200:  MOVWF  19
0201:  BSF    03.5
0202:  MOVF   05,W
0203:  MOVLW  06
0204:  BCF    03.5
0205:  MOVWF  20
0206:  DECFSZ 20,F
0207:  GOTO   206
0208:  NOP
0209:  MOVF   19,W
020A:  BCF    0C.3
....................    setup_vref(FALSE); 
020B:  BSF    03.5
020C:  CLRF   19
....................     
....................    setup_oscillator(OSC_8MHZ|OSC_INTRC);  
020D:  MOVLW  71
020E:  MOVWF  0F
020F:  MOVF   0F,W
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_64); // 8192us 
0210:  MOVF   01,W
0211:  ANDLW  C0
0212:  IORLW  05
0213:  MOVWF  01
....................     
....................     
....................    set_tris_a(0b00010000); 
0214:  MOVLW  10
0215:  MOVWF  05
....................    set_tris_c(0b00000000); 
0216:  MOVLW  00
0217:  MOVWF  07
....................     
....................    
....................     bUpDw=TRUE; 
0218:  BCF    03.5
0219:  BSF    2E.2
....................     bInt100m=FALSE; 
021A:  BCF    2E.1
....................     iNivel=1; 
021B:  MOVLW  01
021C:  MOVWF  31
....................     
....................    iTemperatura=leeTempDS18B20(); 
021D:  CALL   0B5
021E:  MOVF   23,W
021F:  MOVWF  37
0220:  MOVF   22,W
0221:  MOVWF  36
0222:  MOVF   21,W
0223:  MOVWF  35
0224:  MOVF   20,W
0225:  MOVWF  34
0226:  CALL   0ED
0227:  MOVF   21,W
0228:  MOVWF  32
....................     
....................    enable_interrupts(INT_RTCC); 
0229:  BSF    0B.5
....................    enable_interrupts(GLOBAL); 
022A:  MOVLW  C0
022B:  IORWF  0B,F
....................     
....................    delay_ms(1000); 
022C:  MOVLW  04
022D:  MOVWF  34
022E:  MOVLW  FA
022F:  MOVWF  39
0230:  CALL   10C
0231:  DECFSZ 34,F
0232:  GOTO   22E
....................     
....................    while(TRUE) 
....................    { 
....................      visuHP7300(iTemperatura); 
0233:  MOVF   32,W
0234:  MOVWF  34
0235:  GOTO   148
....................      
....................     
....................     if(bInt100m)  //cada 8192us 
0236:  BTFSS  2E.1
0237:  GOTO   249
....................      { 
....................        //visuHP7300(iNivel); 
....................       if(bUpDw) 
0238:  BTFSS  2E.2
0239:  GOTO   243
....................       { 
....................         
....................         if(++iNivel > 40) 
023A:  INCF   31,F
023B:  MOVF   31,W
023C:  SUBLW  28
023D:  BTFSC  03.0
023E:  GOTO   242
....................         { 
....................          iNivel=40; 
023F:  MOVLW  28
0240:  MOVWF  31
....................          bUpDw=FALSE; 
0241:  BCF    2E.2
....................         } 
....................       } 
....................       else 
0242:  GOTO   248
....................       { 
....................          
....................         if(--iNivel ==0xFF)  //¿¿ Roll-over ?? 
0243:  DECF   31,F
0244:  INCFSZ 31,W
0245:  GOTO   248
....................         { 
....................           iNivel=0; 
0246:  CLRF   31
....................           bUpDw=TRUE; 
0247:  BSF    2E.2
....................         }   
....................       }   
....................        
....................        
....................          
....................        bInt100m=FALSE; 
0248:  BCF    2E.1
....................      } 
....................      
....................       
....................     if(bInt5seg)     //muestrea sensor DS1820,cada 5 seg. 
0249:  BTFSS  2E.0
024A:  GOTO   258
....................     { 
....................      iTemperatura=leeTempDS18B20(); 
024B:  CALL   0B5
024C:  MOVF   23,W
024D:  MOVWF  37
024E:  MOVF   22,W
024F:  MOVWF  36
0250:  MOVF   21,W
0251:  MOVWF  35
0252:  MOVF   20,W
0253:  MOVWF  34
0254:  CALL   0ED
0255:  MOVF   21,W
0256:  MOVWF  32
....................      bInt5seg=FALSE; 
0257:  BCF    2E.0
....................     } 
....................      
....................      
....................     PWM(iNivel); 
0258:  MOVF   31,W
0259:  MOVWF  34
025A:  GOTO   161
....................      
....................      
....................    } //While  
025B:  GOTO   233
....................  
.................... } 
025C:  SLEEP

Configuration Fuses:
   Word  1: 3FC4   INTRC_IO NOPROTECT BROWNOUT NOMCLR NOCPD NOWDT PUT IESO FCMEN
